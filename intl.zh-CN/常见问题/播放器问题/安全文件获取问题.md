# 安全文件获取问题

出于安全性的考虑，点播支持对视频进行加密，视频加密之后使用播放器进行解密，这就需要一个加解密的流程，因此播放器下载就需要先拿到一个安全文件。本文档将说明怎么样获取这个安全文件。

## 文档适用人群

对于客户端播放器实现下载需要的”安全图片“的开发者。

## 开启安全下载并生成安全文件

-   1.保证开启点播服务之后，如何开启阿里云点播服务请参考[开启点播](/intl.zh-CN/快速入门/开始使用视频点播.md)。
-   2.在阿里云控制台选择云计算基础服务-\>视频点播-\>全局设置-\>下载设置-\>开启下载功能-\>选择安全下载，如下图。

    ![粘贴图片.png ](https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/2314076061/p179096.png)

-   3.需要提供两个值来获取密钥: app唯一标识如何获取？

    -   安卓：需要提供一个sha1的密钥.如果觉得使用命令行比较麻烦这边提供一段代码段直接生成这个密钥。

        ```
        //这个是获取SHA1的方法
        public static String getCertificateSHA1Fingerprint(Context context) {
          //获取包管理器
          PackageManager pm = context.getPackageManager();
          //获取当前要获取SHA1值的包名，也可以用其他的包名，但需要注意
          //在用其他包名的前提是，此方法传递的参数Context应该是对应包的上下文。
          String packageName = context.getPackageName();
          //返回包括在包中的签名信息
          int flags = PackageManager.GET_SIGNATURES;
          PackageInfo packageInfo = null;
          try {
              //获得包的所有内容信息类
              packageInfo = pm.getPackageInfo(packageName, flags);
          }catch (PackageManager.NameNotFoundException e) {
              e.printStackTrace();
          }
          //签名信息
          Signature[] signatures = packageInfo.signatures;
          byte[] cert = signatures[0].toByteArray();
          //将签名转换为字节数组流
          InputStream input = new ByteArrayInputStream(cert);
          //证书工厂类，这个类实现了出厂合格证算法的功能
          CertificateFactory cf = null;
          try {
              cf = CertificateFactory.getInstance("X509");
          } catch (CertificateException e) {
              e.printStackTrace();
          }
          //X509证书，X.509是一种非常通用的证书格式
          X509Certificate c = null;
          try {
              c = (X509Certificate) cf.generateCertificate(input);
          }catch (CertificateException e) {
              e.printStackTrace();
          }
          String hexString = null;
          try {
              //加密算法的类，这里的参数可以使MD4,MD5等加密算法
              MessageDigest md = MessageDigest.getInstance("SHA1");
              //获得公钥
              byte[] publicKey = md.digest(c.getEncoded());
              //字节到十六进制的格式转换
              hexString = byte2HexFormatted(publicKey);
          }catch (NoSuchAlgorithmException e1) {
              e1.printStackTrace();
          }catch (CertificateEncodingException e) {
              e.printStackTrace();
          }
          return hexString;
        }
        //这里是将获取到得编码进行16进制转换
        private static String byte2HexFormatted(byte[] arr){
          StringBuilder str = new StringBuilder(arr.length * 2);
          for (int i = 0; i < arr.length; i++) 
        {
              String h = Integer.toHexString(arr[i]);
              int l = h.length();
              if (l == 1)
                  h = "0" + h;
              if (l > 2)
                  h = h.substring(l - 2, l);
              str.append(h.toUpperCase());
              if (i < (arr.length - 1))
                  str.append(':');
          }
          return str.toString();}
        ```

    -   iOS：直接填bundleID即可
    -   Windows: 调用SDK的exe的数字签名证书的序列号， 如图

        ![appId.png ](https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/2314076061/p179097.png)

-   4.需要提供两个值来获取密钥: 离线解密私钥怎么填写？填写16-32位的字符串，同时包含大小写字母和数字.
-   5.填写完成之后点击“生成密钥并并下载” 这样就拿到了你想要的安全图片了.

注意:提供获取sha1的算法的前提是获取的默认的keystore的签名的sha1. 如果你最终release包是另外的keystore,建议直接在gradle文件中直接配置release keystore然后通过上面获取sha1的方法获取.

```
//这里演示如何配置keystore,下面的keystore文件开发者可以自由替换, 一下配置的前提是开发者将keystore文件放在项目的根目录下。
    signingConfigs {
        debug {
            storeFile file("$rootDir/debug.keystore")
            storePassword "android"
            keyAlias "androiddebugkey"
            keyPassword "android"
        }
        release {
            storeFile file("$rootDir/debug.keystore")
            storePassword "android"
            keyAlias "androiddebugkey"
            keyPassword "android"
        }
    }
        buildTypes {
        debug {
            multiDexEnabled true
            signingConfig signingConfigs.debug
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        release {
            minifyEnabled true
            multiDexEnabled true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
```

